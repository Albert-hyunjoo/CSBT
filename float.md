# 실수 연산

## 실수 연산 오류
```python
a = 0.01
result = 0.0
for i in range(100):
    result += a
# 기대한 것은 1이지만
# 실제로 나오는 값은 1.00000000000007
```
* 파이썬에서는 실수를 표현하는 데에 일반적인 수학적 표현에 한계가 존재한다.
* 이는 `부동소수점`이라는 비트 활용 **프로그램 실수 표현 방식** 때문이다.

## 부동소수점
* `부동 소수점`은 실수를 표현하는 방식으로, *가수 * (밑)^지수*로 표현한다.
* 통상적으로 *가수*는 *밑*보다 작게 되며, 이렇게 바꾸는 것을 실수의 `정규화`라고 한다.

### 단정도 및 배정도
* `단정도 부동소수점`은 실수를 **32비트**로 표현하며, 부호 **1비트**, 지수부 **8비트**, 가수부 **23비트**이다.
* `배정도 부동소수점`은 실수를 **64비트**로 표현하며, 부호 **1비트**, 지수 **8비트**, 가수부 **52비트**이다.
* 통상적으로 파이썬은 정밀도를 이유로 `배정도 부동소수점`을 주로 사용한다.

### 1바이트 설계하기
* 통상적인 파이썬의 실수형은 `±1.man * 2^(exp-bias)` 이다.
> **[ 1바이트의 실수 7.75로 바꾸는 법 ]**    
> 1) **10진수** 실수를 **2진수** 실수로 바꾸기    
> > 7.75 = 4 (2^2) + 2 (2^1) + 1 (2^0) + 0.5 (2^-1) + 0.25 (2^-2)    
> = **111.11**
> 2) **정규화** 시행하기
> > 111.11 -> 1.1111 * 2^2 (밑수가 가수보다 낮다)    
> 여기서 `man` 값은 1= *0.1111*, `exp-bias`는 *2* 
> 3) 메모리 구조로 배열하기
> > 부호 : 양수면 0, 음수면 1    
> 지수부 : `bias` 는 *2^지수부 -1*로 구한다.    
> 가수부 : *1111*에서 최대한 담을 수 있는 *111* 만
> 4) 최종 대입 및 확인
> > 0 1001 111 = 0x4f (1이 소실되므로 *정밀도 감소*)

## 정밀도에 대한 고찰
* `엡실론 (Epsilon)`은 1.0과 그 다음으로 표현 가능한 수의 차이이다.
* 이 `엡실론` 이하로 표현된다면, (i.e. `epsilon/2`) 사실상 같다고 본다.
* 이 경우에는 **표현 범위는 넓지만, 정밀도는 낮다**고 한다.